<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Pharmaceutical Research Generator</title>
    <!-- Load Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better typography and structure */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .report-content h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #1e3a8a; /* Dark Blue */
            padding-bottom: 0.25rem;
            border-bottom: 2px solid #93c5fd; /* Light Blue Border */
        }
        .report-content p, .report-content ul {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: #333;
        }
        .report-content ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        /* Custom spinner animation */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #1d4ed8;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">

        <h1 class="text-3xl md:text-4xl font-extrabold text-center text-indigo-700 mb-6">
            ðŸ”¬ AI Molecule Research Summary
        </h1>
        <p class="text-center text-gray-600 mb-8">
            Enter a pharmaceutical molecule or drug name to generate a structured, AI-grounded research report on its scientific findings, clinical trials, and potential repurposing.
        </p>

        <!-- Input Section -->
        <div class="space-y-4 mb-8">
            <label for="moleculeInput" class="block text-lg font-medium text-gray-700">Molecule or Drug Name:</label>
            <textarea id="moleculeInput" rows="2" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out" placeholder="e.g., Aspirin, Metformin, Imatinib"></textarea>
            
            <button id="generateButton" onclick="generateReport()" class="w-full flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-lg text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-300 ease-in-out">
                Generate Report
            </button>
        </div>

        <!-- Output Section -->
        <div id="reportContainer">
            <div id="loadingIndicator" class="hidden flex justify-center items-center py-12">
                <div class="spinner"></div>
                <p class="ml-4 text-indigo-600 font-medium">Generating comprehensive report...</p>
            </div>
            
            <div id="reportOutput" class="min-h-32 p-6 bg-gray-50 border border-gray-200 rounded-lg shadow-inner hidden">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">Research Summary</h2>
                <div id="reportContent" class="report-content">
                    <!-- AI generated content will be inserted here -->
                </div>
            </div>

            <div id="sourceContainer" class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg hidden">
                <h3 class="text-lg font-semibold text-yellow-800 mb-2">Sources</h3>
                <ul id="sourceList" class="text-sm text-yellow-700 space-y-1">
                    <!-- Sources will be inserted here -->
                </ul>
            </div>

        </div>

        <!-- Custom Modal for Errors -->
        <div id="errorModal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg p-6 w-full max-w-sm shadow-2xl">
                <h3 class="text-xl font-bold text-red-600 mb-4">Error</h3>
                <p id="errorMessage" class="text-gray-700 mb-6"></p>
                <button onclick="document.getElementById('errorModal').classList.add('hidden')" class="w-full py-2 px-4 bg-red-500 text-white rounded-lg hover:bg-red-600 transition">
                    Close
                </button>
            </div>
        </div>

    </div>

    <script>
        // Custom Modal Function
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorModal').classList.remove('hidden');
        }

        // Global configuration for the API
        const apiKey = "AIzaSyDaZXhPCwkLX8NRKXe-w9_XRidzQYUHScg"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        // Utility function for base64 decoding (for Markdown handling)
        function base64ToUtf8(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return new TextDecoder('utf-8').decode(bytes);
        }

        // Function to handle markdown to HTML conversion (simple approach)
        function markdownToHtml(markdown) {
            let html = markdown;
            // Headers
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            // Bold
            html = html.replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>');
            // Italics
            html = html.replace(/\*(.*)\*/gim, '<em>$1</em>');
            // Newlines to paragraphs
            html = html.replace(/\n\n/g, '</p><p>');
            html = html.replace(/\n/g, '<br>');
            // Lists (simple conversion for the expected structure)
            html = html.replace(/^\* (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // Final cleanup (handle paragraph edge cases)
            if (!html.startsWith('<p>')) {
                html = `<p>${html}`;
            }
            if (!html.endsWith('</p>')) {
                html = `${html}</p>`;
            }

            return html;
        }

        // Exponential Backoff Retry Logic
        async function fetchWithRetry(url, payload, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && i < maxRetries - 1) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Retry
                    }

                    if (!response.ok) {
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    return response.json();

                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error; // Throw after max retries
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function generateReport() {
            const molecule = document.getElementById('moleculeInput').value.trim();
            const loadingIndicator = document.getElementById('loadingIndicator');
            const reportOutputDiv = document.getElementById('reportOutput');
            const reportContentDiv = document.getElementById('reportContent');
            const sourceContainer = document.getElementById('sourceContainer');
            const sourceList = document.getElementById('sourceList');
            const generateButton = document.getElementById('generateButton');

            if (!molecule) {
                showError("Please enter a molecule or drug name to generate a report.");
                return;
            }

            // UI State: Disable button, clear previous output, show loading
            generateButton.disabled = true;
            generateButton.textContent = 'Generating...';
            reportOutputDiv.classList.add('hidden');
            sourceContainer.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');
            reportContentDiv.innerHTML = '';
            sourceList.innerHTML = '';

            const systemPrompt = `You are a specialized pharmaceutical research analyst. Your task is to generate a comprehensive, structured research report based on the latest scientific literature and clinical trial data available for the specified molecule. The output MUST be formatted using Markdown and strictly adhere to the following sections: 'Molecule/Drug Name:', 'Summary of Scientific Findings:', 'Summary of Clinical Trials:', 'Potential New Indications:', and 'Key Insights and Recommendations:' The response must be professional and academic in tone.`;
            
            const userQuery = `Generate a research report for the molecule/drug: ${molecule}. The report must summarize scientific literature and clinical trials related to this molecule and identify potential new indications or repurposing opportunities.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                // Enable Google Search grounding for real-time, grounded scientific data
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const result = await fetchWithRetry(apiUrl, payload);
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const text = candidate.content.parts[0].text;
                    let sources = [];

                    // 1. Extract and display the generated text
                    reportContentDiv.innerHTML = markdownToHtml(text);
                    reportOutputDiv.classList.remove('hidden');

                    // 2. Extract and display grounding sources
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }

                    if (sources.length > 0) {
                        sources.forEach(source => {
                            const li = document.createElement('li');
                            li.innerHTML = `<a href="${source.uri}" target="_blank" class="text-indigo-600 hover:underline">${source.title}</a>`;
                            sourceList.appendChild(li);
                        });
                        sourceContainer.classList.remove('hidden');
                    }

                } else {
                    showError("The AI did not return a valid response. Please try again or refine your query.");
                }

            } catch (error) {
                console.error("Fetch error:", error);
                showError("Could not connect to the AI service. Please check your connection or try again later.");
            } finally {
                // UI State: Hide loading, enable button
                loadingIndicator.classList.add('hidden');
                generateButton.disabled = false;
                generateButton.textContent = 'Generate Report';
            }
        }
    </script>
</body>
</html>
